{"./":{"url":"./","title":"Introduction","keywords":"","body":"温柔群的知识库 协作开发规范 commit 同学们写完笔记，需要把自己的 commit 合并成一个 举例说明： $ git log --oneline 4ee51d6 docs(user): update user/README.md 176ba5d docs(user): update user/README.md 5e829f8 docs(user): add README.md for user f40929f feat(user): add delete user function fc70a21 feat(user): add create user function 7157e9e docs(docs): append test line 'update3' to README.md 5a26aa2 docs(docs): append test line 'update2' to README.md 55892fa docs(docs): append test line 'update1' to README.md 89651d4 docs(doc): add README.md 可以看到我们提交了 5 个 commit。 但是 5 个 commit 太多了，我们想将这些 commit 合并后再提交到 远端 dev 分⽀。 接着，我们合并所有 commit 。在上⼀步中，我们知道 fc70a21是 本地 dev 分⽀的第⼀个 commit ID 其父 commit ID 是 7157e9e，我们需要将7157e9e之前的所有分支进行合并，这时我们可以执行： $ git rebase -i 7157e9e 执行命令后，我们会进⼊到⼀个交互界⾯，在该界面中，我们可以将需要合并的 4 个 commit，都执行 squash 操作 或者也可以每次执行如下的操作 git add . // 添加文件 git commit --amend // 修改最后一次commit的信息 push 同学们的笔记放在 dev 分支进行写作 记录完自己的笔记，一定要进行rebase git pull --rebase origin dev 然后再 push 即可 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:44:29 我的备案号:京ICP备2024087391号-1 "},"languages/cpp.html":{"url":"languages/cpp.html","title":"C++","keywords":"","body":"C++ Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"languages/go.html":{"url":"languages/go.html","title":"Go","keywords":"","body":"Go 方法调用 小明学go语法的时候，看到了下面这段代码 type T struct{} func (t T) M(n int) { } func main() { var t T t.M(1) // 通过类型T的变量实例调用方法M p := &T{} p.M(2) // 通过类型*T的变量实例调用方法M } 这段代码中，方法 M 是类型 T 的方法，那为什么通过 *T 类型变量也可以调用 M 方法呢？ 这是因为 Go 编译器在背后做了转换。也就是，Go 判断 p 的类型为 T，与方法 M 的 receiver 参数类型 T 不一致，就会自动将p.M()转换为(p).M() 无论是 T 类型实例，还是 T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 T 类型的方法。这样，我们在为方法选择 receiver 参数的类型的时候，就不需要担心这个方法不能被与 receiver 参数类型不一致的类型实例调用了 // typecheckmethod handles type-checking of a method call e.g. x.method(args). func typecheckmethod(n *Node, top int) *Node { // Get the method set for the receiver type. mt := MethodType(n.Left.Type) // Check if the method exists in the method set. m := Lookdot(n.Left.Type, n.Right.Sym) if m == nil { // If not found, check if the method can be applied to a pointer receiver. if n.Left.Type.IsPtr() { baseType := n.Left.Type.Elem() m = Lookdot(baseType, n.Right.Sym) if m != nil { n.Left = Nod(OIND, n.Left, nil) n.Left = typecheck(n.Left, ctxExpr) } } } // If the method is still not found, throw an error. if m == nil { yyerror(\"type %v has no method %v\", n.Left.Type, n.Right.Sym) return n } // Perform further type-checking and method call handling. n.Type = m.Type n.Op = OCALL n.Left = m n.List = typecheck(n.List, ctxExpr) return n } 方法集合 案例一 小明学go的时候，看到下面这段代码 type Interface interface { M1() M2() } type T struct{} func (t T) M1() {} func (t *T) M2() {} func main() { var t T var pt *T var i Interface i = pt i = t } 小明发现代码还没执行，编译器就已经开始报错了。 错误信息：T 没有实现 Interface 类型方法列表中的 M2，因此类型 T 的实例 t 不能赋值给 Interface 变量。 可是，为什么呀？为什么 *T 类型的 pt 可以被正常赋值给 Interface 类型变量 i，而 T 类型的 t 就不行呢？如果说 T 类型是因为只实现了 M1 方法，未实现 M2 方法而不满足 Interface 类型 的要求，那么 *T 类型也只是实现了 M2 方法，并没有实现 M1 方法啊？ 你知道为什么吗，帮帮小明 Go 语言规定，T 类型的方法集合包含所有以 T 为 receiver 参数类型的方法，以 及所有以 T 为 receiver 参数类型的方法。所以pt的方法集合中包含了M1和M2方法，因此pt实现了接口，而t的方法集合中只有M1，未实现接口。 方法集合的作用： 如果某类型 T 的方法集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I 方法集合的超集，那么我们就说这个类型 T 实现了接口 I。或者说，方法集合这个概念在 Go 语言中的主要用途，就是用来判断某个类型是否实现了某个接口。 案例二 小明最近学到了一个新知识 在Go语言中，当一个类型实现了fmt.Stringer接口，fmt包的相关函数（如fmt.Println、fmt.Printf等）会自动调用该类型的String方法来获取其字符串表示。fmt.Stringer接口定义如下： type Stringer interface { String() string } 只要一个类型实现了这个接口，fmt包就会使用String方法的返回值来表示该类型的实例。具体来说，当你调用fmt.Println(deque)时，如果deque类型实现了String方法，fmt包会调用deque.String()来获取字符串表示，然后输出该字符串。 小明自己实现了一个双端队列，它想为这个队列添加一个方法，展示队列中所有的元素。 他的代码如下： func (d *deque) String() string { var elements []string for i := len(d.l) - 1; i >= 0; i-- { elements = append(elements, fmt.Sprintf(\"%v\", d.l[i])) } for _, value := range d.r { elements = append(elements, fmt.Sprintf(\"%v\", value)) } return fmt.Sprintf(\"[%s]\", strings.Join(elements, \", \")) } func NewDeque() deque { return deque{} } func main() { q := NewDeque() q.append(3) q.append(4) q.append(5) q.appendLeft(1) fmt.Println(q) } 奇怪了，输出怎么是{[1] [3 4 5]}，你能帮小明找找原因吗？ 根据案例一的知识点，String方法的接收者是deque，而q是deque{}类型，他的方法集合不包括`deque，因此没能实现Stringer接口，所以不会自动调用String方法作为自定义的输出。只需要修改为q = &deque{}`就可以正常输出了。 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:49:58 我的备案号:京ICP备2024087391号-1 "},"languages/java.html":{"url":"languages/java.html","title":"Java","keywords":"","body":"Java Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"algorithms/algorithm.html":{"url":"algorithms/algorithm.html","title":"算法","keywords":"","body":"这里是算法 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:37:23 我的备案号:京ICP备2024087391号-1 "},"algorithms/algorithm/input.html":{"url":"algorithms/algorithm/input.html","title":"输入输出模板","keywords":"","body":"package main import ( \"bufio\" . \"fmt\" \"os\" ) func solve() { } var in = bufio.NewReader(os.Stdin) var out = bufio.NewWriter(os.Stdout) func main() { defer out.Flush() var T int for Fscan(in, &T); T > 0; T-- { solve() } } 模板说明，当遇到处理大量的输入数据或者输出数据的时候，用模板会快很多 缓冲输入（bufio.NewReader）： bufio.NewReader 包装了 os.Stdin 创建一个缓冲读取器。这意味着程序一次性从标准输入读取更大块的数据，从而减少读取操作的次数。 Fscan 函数从这个缓冲读取器中读取数据，这比每次直接从 os.Stdin 读取要快得多。 缓冲输出（bufio.NewWriter）： bufio.NewWriter 包装了 os.Stdout 创建一个缓冲写入器。这意味着程序一次性向标准输出写入更大块的数据，从而减少写入操作的次数。 Fprintln 函数向这个缓冲写入器中写数据，这比每次直接向 os.Stdout 写要快得多。 defer out.Flush() 确保在程序终止前将所有缓冲的数据刷新到标准输出。 减少系统调用： 系统调用（如从标准输入读取或向标准输出写入）是相对较慢的操作。通过使用缓冲，程序减少了这些调用的次数，从而提高了整体性能。 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:46:11 我的备案号:京ICP备2024087391号-1 "},"algorithms/algorithm/math.html":{"url":"algorithms/algorithm/math.html","title":"筛质数","keywords":"","body":"筛质数 func GetPrimeList(n int) []int { // p[i] == 1 表示为质数， p[i] == -1 表示为合数 p := make([]int, n+1) for i := 2; i Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:46:17 我的备案号:京ICP备2024087391号-1 "},"algorithms/datastruct.html":{"url":"algorithms/datastruct.html","title":"数据结构","keywords":"","body":"这里是数据结构 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:37:17 我的备案号:京ICP备2024087391号-1 "},"algorithms/data-structures/segment.html":{"url":"algorithms/data-structures/segment.html","title":"线段树","keywords":"","body":"基础线段树 单点修改，区间查询 单点修改：对nums[i]的值更新为val 区间查询：返回nums[l, r]之间的元素和 构造线段树-build 接收数组nums，根据nums构造出线段树SegmentTree 线段树上每一个结点是一个区间，根节点代表$[1,n]$的区间，叶子结点代表单点 构造线段树，实际上就是对每个线段树上的结点赋值，也就是求出线段树每个结点对应区间的元素和 build操作通过递归实现，先求出子节点的值，然后更新父节点的值，代码如下： func (s *SegmentTree) build(o, l, r int) { if l == r { s.sum[o] = s.nums[l-1] return } mid := (l + r) >> 1 s.build(o 单点修改-update 线段树上的一个结点会有若干父节点，当修改了某一个结点的值，对应的父节点的值也需要修改。 由于需要修改的下标index是已知的，当index小于等于mid，就只需要去搜索左子树。反之亦然。 func (s *SegmentTree) update(o, l, r, idx, val int) { if l == r { s.sum[o] = val return } mid := (l + r) >> 1 if idx 区间查询-query 线段树上的每个结点都存放了对应区间的元素和 假设我们需要查询的区间为$[L, R]$ 对于结点node对应的区间$[l,r]$，该区间的中点为mid 查询的区间要么全部在mid左边，要么在右边，要么一部分在左边、一部分在右边 判断清楚所有的情况即可 func (s *SegmentTree) query(o, l, r, L, R int) int { if L = r { return s.sum[o] } mid := (l + r) >> 1 if R mid { return s.query((o 优化参数-Update 避免用户使用函数的时候，考虑过多的参数。因此单独写一个Update函数，简单封装一下 注意，线段树的结点下标是从1开始的，用户使用的index下标从0开始 func (s *SegmentTree) Update(index int, val int) { s.update(1, 1, len(this.nums), index+1, val) } 优化参数-SumRange 避免参数过多，对query函数进行简单封装 func (s *SegmentTree) SumRange(left int, right int) int { return s.query(1, 1, len(this.nums), left+1, right+1) } 完整模板 package main type SegmentTree struct { sum []int // 下标从1开始 nums []int // 下标从0开始 } func (s *SegmentTree) build(o, l, r int) { if l == r { s.sum[o] = s.nums[l-1] return } mid := (l + r) >> 1 s.build(o> 1 if idx = r { return s.sum[o] } mid := (l + r) >> 1 if R mid { return s.query((o 0 { x >>= 1 size += 1 } return size } func Constructor(nums []int) SegmentTree { tree := SegmentTree{ sum: make([]int, 2 值域离散化 当值域存在复数，或者值域特别大，但是数组长度又比较小的时候，需要使用离散化的技巧。 对数组进行哈希，排序。此时每个数组的下标就和元素值进行了映射，从而达到离散化的效果。 线段树二分 查询某个区间中满足条件的最小元素 以查询前maxRow行中，观众数不超过m-k，并且下标最小的行为例，学习线段树二分的写法 用线段树维护每个区间上的观众数的最小值 当前区间的最小值 > m-k，表示不存在可以容纳k个观众的行，直接返回0 当前区间只有一个元素，l = r，表示找到了最小的下标 左子树对应的最小值 ≤ m-k，表示左子树存在可以容纳k个观众的行，递归左子树 左子树不存在这样的行，递归右子树（递归的前提是maxRow在mid的右边） 无法递归，直接返回0 具体代码如下 func (t *BookMyShow) Index(o, l, r, val, R int) int { // 返回区间[1, R]中小于等于val的最靠左的位置，不存在返回0 if t.min[o] > val { // 整个区间的元素都大于val return 0 } if l == r { return l } mid := (l + r) >> 1 if t.min[o 动态开点线段树 当值域过大，无法直接开辟等量的数组时，一般采用离散化。但是如果事先不知道数据，离散化将变得困难。此时使用动态开点的方法。 以2426这道题举例，值域包含负数，需要离散化或者使用动态开点 此时的query和add操作，需要进行修改 使用的时候再开辟空间，而不是事先就开辟好空间。因此add的代码为 func (s *SegmentTree) add(l, r, idx, val int) { if l == r { s.sum += val return } mid := (l + r) >> 1 if s.left == nil { s.left = &SegmentTree{} } if s.right == nil { s.right = &SegmentTree{} } if idx 区别在于如果需要继续递归，此时再开辟对应的子节点。 查询的代码如下 func (s *SegmentTree) query(l, r, L, R int) int { if L > 1 sum := 0 if L mid && s.right != nil { sum += s.right.query(mid+1, r, L, R) } return sum } 区别在于每次查询的时候，需要判断该节点是否存在左孩子和右孩子。只有存在，才可以继续递归 具体应用 查询区间和 查询区间最值 查询区间大于x的元素个数 查询某个区间中满足条件的最小元素 习题： 307. 区域和检索 - 数组可修改 - 基础线段树 2426. 满足不等式的数对数目 - 基础线段树 + 离散化 + 公式变形 || 也可用动态开点的方式求解 2286. 以组为单位订音乐会的门票 - 基础线段树 + 线段树二分 2276. 统计区间中的整数数目 - 基础线段树 + 动态开点 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:48:41 我的备案号:京ICP备2024087391号-1 "},"algorithms/data-structures/heapq.html":{"url":"algorithms/data-structures/heapq.html","title":"最小/最大堆","keywords":"","body":"go提供了heap的接口，只需要实现对应的函数即可 type pair struct{ x, y, dist int } type hp []pair func (h hp) Len() int { return len(h) } func (h hp) Less(i, j int) bool { return h[i].dist 注意我们最后封装了两个函数,push和pop。 不可以直接调用h.Pop()和h.Push()，这只是简单的在切片上进行push和pop而已。 要调用heap.Push(h, xxx)和heap.Pop(x)，才可以实现优先队列的功能 使用heap之前，有五个方法，需要用户来实现 Len() Less() Swap() Push() Pop() 因为heap.Push(参数1， 参数2)中的第一个参数是一个Interface的接口类型，该接口需要实现上述的五个方法 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:46:48 我的备案号:京ICP备2024087391号-1 "},"algorithms/data-structures/deque.html":{"url":"algorithms/data-structures/deque.html","title":"双端队列","keywords":"","body":"力扣和cf可以用 type deque struct { l, r []any } func (d *deque) append(x any) { d.r = append(d.r, x) } func (d *deque) appendLeft(x any) { d.l = append(d.l, x) } func (d *deque) pop() any { if len(d.r) > 0 { x := d.r[len(d.r)-1] d.r = d.r[:len(d.r)-1] return x } else if len(d.l) > 0 { x := d.l[0] d.l = d.l[1:] return x } return nil } func (d *deque) popLeft() any { if len(d.l) > 0 { x := d.l[len(d.l)-1] d.l = d.l[:len(d.l)-1] return x } else if len(d.r) > 0 { x := d.r[0] d.r = d.r[1:] return x } return nil } func (d *deque) String() string { var elements []string for i := len(d.l) - 1; i >= 0; i-- { elements = append(elements, fmt.Sprintf(\"%v\", d.l[i])) } for _, value := range d.r { elements = append(elements, fmt.Sprintf(\"%v\", value)) } return fmt.Sprintf(\"[%s]\", strings.Join(elements, \", \")) } func (d *deque) Len() int { return len(d.l) + len(d.r) } func NewDeque() *deque { return &deque{} |~ ~~ 牛客用 type deque struct { l, r []interface{} } func (d *deque) append(x interface{}) { d.r = append(d.r, x) } func (d *deque) appendLeft(x interface{}) { d.l = append(d.l, x) } func (d *deque) pop() interface{} { if len(d.r) > 0 { x := d.r[len(d.r)-1] d.r = d.r[:len(d.r)-1] return x } else if len(d.l) > 0 { x := d.l[0] d.l = d.l[1:] return x } return nil } func (d *deque) popLeft() interface{} { if len(d.l) > 0 { x := d.l[len(d.l)-1] d.l = d.l[:len(d.l)-1] return x } else if len(d.r) > 0 { x := d.r[0] d.r = d.r[1:] return x } return nil } func (d *deque) Len() int { return len(d.l) + len(d.r) } func NewDeque() *deque { return &deque{} } Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:46:46 我的备案号:京ICP备2024087391号-1 "},"basics/network.html":{"url":"basics/network.html","title":"计算机网络","keywords":"","body":"计算机网络 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"basics/os.html":{"url":"basics/os.html","title":"操作系统","keywords":"","body":"操作系统 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"databases/mysql.html":{"url":"databases/mysql.html","title":"MySQL","keywords":"","body":"MySQL Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"databases/redis.html":{"url":"databases/redis.html","title":"Redis","keywords":"","body":"Redis Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"distributed/":{"url":"distributed/","title":"分布式","keywords":"","body":"分布式 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"message/":{"url":"message/","title":"kafka","keywords":"","body":"kafka Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"k8s/high.html":{"url":"k8s/high.html","title":"pv","keywords":"","body":"这里是高级篇的 k8s 知识 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 18:38:10 我的备案号:京ICP备2024087391号-1 "},"k8s/high/pv.html":{"url":"k8s/high/pv.html","title":"pv","keywords":"","body":"pv 思考题 HostPath 类型的 PV 要求节点上必须有相应的目录，如果这个目录不存在（比如忘记创建了）会怎么样呢？ 会自动创建的 你对使用 PV/PVC/StorageClass 这三个对象来分配存储的流程有什么看法？它们的抽象是好还是坏？ 什么是 PersistentVolume Pod 里的容器是由镜像产生的，而镜像文件本身是只读的，进程要读写磁盘只能用一个临时的存储空间，一旦 Pod 销毁，临时存储也就会立即回收释放，数据也就丢失了。为了保证即使 Pod 销毁后重建数据依然存在，我们就需要找出一个解决方案，让 Pod 用上真正的“虚拟盘”。怎么办呢？ 其实，Kubernetes 的 Volume 对数据存储已经给出了一个很好的抽象，它只是定义了有这么一个“存储卷”，而这个“存储卷”是什么类型、有多大容量、怎么存储，我们都可以自由发挥。Pod 不需要关心那些专业、复杂的细节，只要设置好 volumeMounts，就可以把 Volume 加载进容器里使用。 所以，Kubernetes 就顺着 Volume 的概念，延伸出了 PersistentVolume 对象，它专门用来表示持久存储设备，但隐藏了存储的底层实现，我们只需要知道它能安全可靠地保管数据就可以了（由于 PersistentVolume 这个词很长，一般都把它简称为 PV）。 那么，集群里的 PV 都从哪里来呢？ 作为存储的抽象，PV 实际上就是一些存储设备、文件系统，比如 Ceph、GlusterFS、NFS，甚至是本地磁盘，管理它们已经超出了 Kubernetes 的能力范围，所以，一般会由系统管理员单独维护，然后再在 Kubernetes 里创建对应的 PV。要注意的是，PV 属于集群的系统资源，是和 Node 平级的一种对象，Pod 对它没有管理权，只有使用权。 什么是 PersistentVolumeClaim/StorageClass 现在有了 PV，我们是不是可以直接在 Pod 里挂载使用了呢？还不行。因为不同存储设备的差异实在是太大了：有的速度快，有的速度慢；有的可以共享读写，有的只能独占读写；有的容量小，只有几百 MB，有的容量大到 TB、PB 级别…… 这么多种存储设备，只用一个 PV 对象来管理还是有点太勉强了，不符合“单一职责”的原则，让 Pod 直接去选择 PV 也很不灵活。于是 Kubernetes 就又增加了两个新对象PersistentVolumeClaim 和 StorageClass，用的还是“中间层”的思想，把存储卷的分配管理过程再次细化。 我们看这两个新对象。PersistentVolumeClaim，简称 PVC，从名字上看比较好理解，就是用来向 Kubernetes 申请存储资源的。PVC 是给 Pod 使用的对象，它相当于是 Pod 的代理，代表 Pod 向系统申请 PV。一旦资源申请成功，Kubernetes 就会把 PV 和 PVC 关联在一起，这个动作叫做“绑定”（bind）。 但是，系统里的存储资源非常多，如果要 PVC 去直接遍历查找合适的 PV 也很麻烦，所以就要用到 StorageClass。StorageClass 的作用有点像第 21 讲里的 IngressClass，它抽象了特定类型的存储系统（比如 Ceph、NFS），在 PVC 和 PV 之间充当“协调人”的角色，帮助 PVC 找到合适的 PV。也就是说它可以简化 Pod 挂载“虚拟盘”的过程，让 Pod 看不到 PV 的实现细节。 用 yaml 描述 pv apiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test accessModes: - ReadWriteOnce capacity: storage: 10Mi hostPath: path: /tmp/host-10m-pv/ PV 对象的文件头部分很简单，还是 API 对象的“老一套”，我就不再详细解释了，重点看它的 spec 部分，每个字段都很重要，描述了存储的详细信息。 storageClassName就是刚才说过的，对存储类型的抽象 StorageClass。这个 PV 是我们手动管理的，名字可以任意起，这里我写的是 host-test，你也可以把它改成 manual、hand-work 之类的词汇。 accessModes定义了存储设备的访问模式，简单来说就是虚拟盘的读写权限，和 Linux 的文件访问模式差不多，目前 Kubernetes 里有 3 种：ReadWriteOnce：存储卷可读可写，但只能被一个节点上的 Pod 挂载。ReadOnlyMany：存储卷只读不可写，可以被任意节点上的 Pod 多次挂载。ReadWriteMany：存储卷可读可写，也可以被任意节点上的 Pod 多次挂载。你要注意，这 3 种访问模式限制的对象是节点而不是 Pod，因为存储是系统级别的概念，不属于 Pod 里的进程。显然，本地目录只能是在本机使用，所以这个 PV 使用了 ReadWriteOnce。 第三个字段capacity就很好理解了，表示存储设备的容量，这里我设置为 10MB。再次提醒你注意，Kubernetes 里定义存储容量使用的是国际标准，我们日常习惯使用的 KB/MB/GB 的基数是 1024，要写成 Ki/Mi/Gi，一定要小心不要写错了，否则单位不一致实际容量就会对不上。 最后一个字段hostPath最简单，它指定了存储卷的本地路径，也就是我们在节点上创建的目录。用这些字段把 PV 的类型、访问模式、容量、存储位置都描述清楚，一个存储设备就创建好了。 用 yaml 描述 pvc apiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi PVC 的内容与 PV 很像，但它不表示实际的存储，而是一个“申请”或者“声明”，spec 里的字段描述的是对存储的“期望状态”。 所以 PVC 里的 storageClassName、accessModes 和 PV 是一样的，但不会有字段 capacity，而是要用 resources.request 表示希望要有多大的容量。 这样，Kubernetes 就会根据 PVC 里的描述，去找能够匹配 StorageClass 和容量的 PV，然后把 PV 和 PVC“绑定”在一起，实现存储的分配 如何给 pod 挂载 pvc apiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp 先要在 spec.volumes 定义存储卷，然后在 containers.volumeMounts 挂载进容器。 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-19 00:32:46 我的备案号:京ICP备2024087391号-1 "},"share/ggboy.html":{"url":"share/ggboy.html","title":"经验分享","keywords":"","body":"还记得我在力扣的第一次发帖 - 为什么少有看见讨论python的岗位？ 前辈们真诚的回答和建议，让我受益匪浅。 如今，三年之后，我好像也有一些建议可以给到大家，特别是学历背景和我相似的同学。先说说我本人的情况 学历 双非本硕 算法 力扣2000题左右，其他加起来应该有200题左右 项目 两个业务类，三个轮子类 八股文 背了go + mysql + redis + 计网，操作系统没咋背。然后简历中写到的知识点深入学习 秋招情况： 投递简历500+（包括boss的沟通次数），面试次数寥寥无几。除了标注，其余均为go后端 金山办公 - hr面挂 深信服 - hr面挂，薪资要的15 14（没想通我当时要这么低，为啥被挂了） 湖南广电 - 一面挂 掌上先机 - 三轮面，oc，薪资18 14，公积金5%，拒 图森未来 - 一面挂 百姓网（py后端） - 六轮面，oc 华顺信安 - 五轮面，薪资要的18 * 14，要高了，被拒 品高股份 - 一面挂 道客云 - 三面通过，无法提前实习，被拒 hashdata（数据库内核） - 一面挂 精灵云（cpp后端） - 群面挂 大概回忆的起的就是这些公司，可以看到就算hr面之后，也会因为谈薪的问题而被拒绝。笔试绝大部分是满分进面，获得面试机会略显不易。 春招情况： 投递简历50+，此时主要是投递package30+的公司 腾娱互动 - 一面（面试官说开不了我的期望，所以面完就没下文了） 旷视科技 - 四轮面，oc。 58同城 - 三轮oc（22k16，拒） 金山 - 三面oc（20k14，拒） 小米 - 二面（拒） 上面是我的求职情况，可以看到的是学历是敲门砖，但是进入面试之后大家其实是一样的。所以我觉得运气+实力=offer 总结一下就是学历不占优的同学，最后拿到了比较高的package。接下来是一些时间线和建议给到25届的学弟学妹萌26届，27届的同学可以依次类推。 2023/12/01 - 2024/03/01 go语言 go语言达到刷hot200的水平 GMP，垃圾回收，并发编程要相当熟练 有多余的时间，研读go语言设计与实现这本书 有多余的时间，把常见的数据结构手撕下。比如堆，哈希表，跳表 八股文 简历中写什么，就去背什么 计网和操作系统 - http和tcp，进程线程相关章节，需要相当熟悉 有多余的时间，把项目中用到的技术，深入学习 有多余的时间，把计网和os中其他的章节，多看几遍。 项目 回答一下几个问题 为什么做这个项目 单纯玩具项目？还是有自己的思考在里面？ 思考体现在哪里？ 了解过其他类似的项目吗？ 对比你的项目和其他项目的优劣 这几个问题可能有点抽象，我举个例子好了。 假设我写了个博客，这可能是大家简历中比较容易提到的。 为什么做这个项目？ - 希望记录自己的学习过程 单纯玩具项目？还是有自己的思考在里面？ 一开始是一个小demo，比如一开始只有简单的增删改查。但是后面当我使用语雀，飞书这些工具的时候，发现编辑帖子可以有贼多的功能，markdown，加粗，斜线啥的。我就寻思人家是怎么做的，xxx后，实现了类似的功能。然后呢，我还增加了搜索功能，通过es快速搜寻相关的帖子。 大概就是这个意思，对一个简单的demo不断地优化迭代，最后就成了自己有思考地项目。 了解过其他类似项目吗？当然，我平时使用的力扣，飞书，语雀都有类似地功能。。。 对比你的项目和其他项目地优劣 像这种项目，咱们自己做的项目应该是毫无优势可言。所以建议同学们还是可以做偏轮子地项目，比如mit6.824,cmu15545之类的。那你聊优势就会有的聊。 2024/03/01 - 2024/06/30 海投简历 - 笔试 - 面试 - 复盘面试 复盘面试是最为重要的，一定保证自己同样的问题不会再犯。 2024/07/01 - 2024/08/31 认真工作，记录自己的需求如何从0到1的。产品提需求 -> 需求评审 -> 排期 -> 写代码 -> 前后端联调 -> 测开介入 -> 改bug -> 完成需求 可能同学们实习的时候，流程会更复杂。不过最重要的是理解数据流的走向，加深对整个代码模块的理解，面试才有的聊。所以这段时间，可以每天复盘一下自己的工作内容，大厂同学可能会经历串讲的煎熬，这其实对秋招的面试是相当有帮助的。 2024/09/01 - 2024/11/31 把简历中提到的所有知识点，列个清单，挨个深入学习。 比如你提到mysql，你至少要知道mysql的架构（服务层和引擎层）。然后select语句发送到mysql，会发生哪些有趣的事情，你需要如数家珍。 简而言之，就是简历吃透，此时不用大段时间的背八股文了，遇到每一个面试题都认真记录即可。 以上是我能想到的一些问题，那我还是总结下。大家不用依葫芦画瓢，只需要把时间线提前即可。 本科的同学，大三下是你们暑期实习。因此你大三上开始准备。 硕士研究生，研二上开始准备。 我最喜欢的一句话是二郎神对沉香说的，原话是 一定是平时练功的时候总是差不多、差不多，到了关键时候就总是差一点。 这里我把他稍作修改： 一定是平时学习的时候总是差不多、差不多，到了面试的时候就总是差一点。 最后给我的群友表个白，我几乎能回忆起每个同学在群里面的发言。 对每一个我熟悉的小伙伴表白下： 前年秋招的学长zzxn 去年秋招的江月，gg_bugmaker,小红花，小林 还有一直坚持在群里面讨论算法的lfss,ikun,苯环 还有群里面气氛活跃组，gg_null，小张，温柔，钢，小番薯 还有我在群里面认识的好朋友少年男 还有群里面的每一位同学 正是因为有你们的陪伴，我才能在屡屡受挫的秋招和春招中不断地战斗。 当然，最后还要感谢力扣的每一位同学，对我的问题热心的解答。 可能有一些同学因为各种各样的原因离开了，但是我还是想说：感谢你们的陪伴 江湖很小，也许会再相见。 ggboy 2024/04/28 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "},"share/ggblog.html":{"url":"share/ggblog.html","title":"博客搭建全过程","keywords":"","body":"博客搭建 技术栈 GitBook: 用于生成和维护静态网站的工具。你使用了 gitbook build 来生成静态文件和 gitbook serve 来提供本地服务器支持。 Nginx: 一个流行的高性能 web 服务器和反向代理服务器，用于部署和服务 GitBook 生成的静态文件。 inotifywait: 监控文件系统事件的工具，使用 inotifywait 监控 Markdown 文件的变化，并在文件变化时自动执行 GitBook 构建。 Systemd: 一个系统和服务管理器，用于管理和运行后台服务。你配置了 gitbook-watch.service 来后台运行脚本，自动检测文件变化并重建 GitBook。 权限管理: 管理文件和目录的权限，确保 gitbook 和 inotifywait 具有适当的权限进行操作。 Bash 脚本: 编写了 Bash 脚本来自动化文件监控和 GitBook 构建的流程。 文件系统操作: 使用 find 命令和 xargs 处理和监控文件变化。 搭建过程 1. 设置 Nginx 反向代理 为了让 GitBook 更方便地通过域名访问，可以通过 Nginx 设置反向代理，将外部请求转发到 GitBook 的 321 端口。 配置 Nginx 编辑 /etc/nginx/sites-available/gitbook 文件： sudo vim /etc/nginx/sites-available/gitbook 添加以下内容，将 GitBook 端口反向代理到 80 端口（或者你想使用的端口）： server { listen 80; server_name yourdomain.com; location / { proxy_pass http://localhost:321; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 启用 Nginx 配置 启用配置并重新启动 Nginx： sudo ln -s /etc/nginx/sites-available/gitbook /etc/nginx/sites-enabled/ sudo systemctl restart nginx 既然你已经通过 gitbook serve & 在后台运行 GitBook，并且它默认在 4000 端口运行，接下来可以做一些优化，让它更好地与 GitHub 关联，并且长期稳定运行。 2. 使用 systemd 管理 GitBook 服务 为了确保 GitBook 在服务器重启后依然能够自动启动，你可以创建一个 systemd 服务来管理 GitBook。 创建 gitbook.service 文件 在 /etc/systemd/system/ 目录下创建一个 gitbook.service 文件： sudo vim /etc/systemd/system/gitbook.service 文件内容如下： [Unit] Description=GitBook Service After=network.target [Service] Type=simple ExecStart=/usr/local/bin/gitbook serve /path/to/your/gitbook --port 321 WorkingDirectory=/path/to/your/gitbook Restart=always User=youruser Group=yourgroup [Install] WantedBy=multi-user.target 将 /path/to/your/gitbook 替换为 GitBook 项目路径，将 youruser 替换为你的服务器用户，yourgroup 替换为用户组。 启动并启用服务 创建好服务文件后，运行以下命令启动并启用 GitBook 服务： sudo systemctl daemon-reload sudo systemctl start gitbook sudo systemctl enable gitbook 这将确保 GitBook 在服务器启动时自动运行，并且在任何情况下崩溃后会自动重启。 你可以通过 systemd 来管理这个监听和自动重新编译的脚本。具体步骤如下： 3. 监听 .md 文件的变更 确保你已经有了用于监听 Markdown 文件变化并自动重新编译 GitBook 的 Bash 脚本（如你提供的脚本）。你可以将它保存在 /home/ubuntu/projects/watch-and-build.sh 中。 #!/bin/bash WATCH_DIR=\"your-gitbook-path\" # 监控 Markdown 文件的变化，包括子目录中的文件 inotifywait -m -r -e modify,create,delete --format '%w%f' \"${WATCH_DIR}\" | while read -r file; do # 如果变化的文件是 Markdown 文件 if [[ \"$file\" == *.md ]]; then echo \"Markdown file changed: $file, restarting GitBook service...\" sudo systemctl restart gitbook fi done 创建 systemd 服务文件 创建一个新的 systemd 服务文件，比如 /etc/systemd/system/gitbook-watch.service，用于管理这个脚本。 sudo vim /etc/systemd/system/gitbook-watch.service 在文件中添加以下内容： [Unit] Description=Watch and Build GitBook After=network.target [Service] ExecStart=/bin/bash /home/ubuntu/projects/watch-and-build.sh Restart=always User=ubuntu Group=ubuntu [Install] WantedBy=multi-user.target ExecStart：指向你的脚本路径。 Restart=always：确保脚本在崩溃或意外停止时会自动重启。 User 和 Group：设置为运行服务的用户和用户组。 启动并启用服务 接下来，运行以下命令来启动和启用服务： sudo systemctl daemon-reload sudo systemctl start gitbook-watch.service sudo systemctl enable gitbook-watch.service 这将启动 gitbook-watch 服务，并在系统启动时自动启动该服务。 至此，一个简单的博客就搭建完毕了，后续将 github 关联起来即可。 Copyright ©2024-2024 cnggboy 版权所有 all right reserved，powered by Gitbook该文章修订时间： 2024-09-13 19:19:01 我的备案号:京ICP备2024087391号-1 "}}